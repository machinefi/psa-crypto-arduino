<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSA Crypto: Secure Element Key Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSA Crypto
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Secure Element Key Management</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsa__drv__se__key__management__t.html">psa_drv_se_key_management_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing all of the function pointers needed to for secure element key management.  <a href="structpsa__drv__se__key__management__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaab9a5d39285c68ac29264017e0119d98"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__se__key__management.html#gaab9a5d39285c68ac29264017e0119d98">psa_drv_se_allocate_key_t</a>) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, void *persistent_data, const <a class="el" href="group__attributes.html#ga8eedc0a49d58b566770c81a1a617f63e">psa_key_attributes_t</a> *attributes, <a class="el" href="group__se__key__management.html#ga984d5535962320e0c4692bb4ede486ef">psa_key_creation_method_t</a> method, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> *key_slot)</td></tr>
<tr class="memdesc:gaab9a5d39285c68ac29264017e0119d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that allocates a slot for a key.  <a href="group__se__key__management.html#gaab9a5d39285c68ac29264017e0119d98">More...</a><br /></td></tr>
<tr class="separator:gaab9a5d39285c68ac29264017e0119d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26c4b96c6d68dbd74b0512475d29f934"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__se__key__management.html#ga26c4b96c6d68dbd74b0512475d29f934">psa_drv_se_validate_slot_number_t</a>) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, void *persistent_data, const <a class="el" href="group__attributes.html#ga8eedc0a49d58b566770c81a1a617f63e">psa_key_attributes_t</a> *attributes, <a class="el" href="group__se__key__management.html#ga984d5535962320e0c4692bb4ede486ef">psa_key_creation_method_t</a> method, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot)</td></tr>
<tr class="memdesc:ga26c4b96c6d68dbd74b0512475d29f934"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that determines whether a slot number is valid for a key.  <a href="group__se__key__management.html#ga26c4b96c6d68dbd74b0512475d29f934">More...</a><br /></td></tr>
<tr class="separator:ga26c4b96c6d68dbd74b0512475d29f934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e04e71aff4837259e54598708edcf7d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__se__key__management.html#ga9e04e71aff4837259e54598708edcf7d">psa_drv_se_import_key_t</a>) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot, const <a class="el" href="group__attributes.html#ga8eedc0a49d58b566770c81a1a617f63e">psa_key_attributes_t</a> *attributes, const uint8_t *data, size_t data_length, size_t *bits)</td></tr>
<tr class="memdesc:ga9e04e71aff4837259e54598708edcf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that imports a key into a secure element in binary format.  <a href="group__se__key__management.html#ga9e04e71aff4837259e54598708edcf7d">More...</a><br /></td></tr>
<tr class="separator:ga9e04e71aff4837259e54598708edcf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf8c22c4a5b87035fcb594858d68e1ba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__se__key__management.html#gaaf8c22c4a5b87035fcb594858d68e1ba">psa_drv_se_destroy_key_t</a>) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, void *persistent_data, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot)</td></tr>
<tr class="memdesc:gaaf8c22c4a5b87035fcb594858d68e1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that destroys a secure element key and restore the slot to its default state.  <a href="group__se__key__management.html#gaaf8c22c4a5b87035fcb594858d68e1ba">More...</a><br /></td></tr>
<tr class="separator:gaaf8c22c4a5b87035fcb594858d68e1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c51abdf1eb2165b800f1de017ed42fb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__se__key__management.html#ga6c51abdf1eb2165b800f1de017ed42fb">psa_drv_se_export_key_t</a>) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key, uint8_t *p_data, size_t data_size, size_t *p_data_length)</td></tr>
<tr class="memdesc:ga6c51abdf1eb2165b800f1de017ed42fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that exports a secure element key in binary format.  <a href="group__se__key__management.html#ga6c51abdf1eb2165b800f1de017ed42fb">More...</a><br /></td></tr>
<tr class="separator:ga6c51abdf1eb2165b800f1de017ed42fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62df4bbc6b63ab5ef8183012b12a6cf8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__se__key__management.html#ga62df4bbc6b63ab5ef8183012b12a6cf8">psa_drv_se_generate_key_t</a>) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot, const <a class="el" href="group__attributes.html#ga8eedc0a49d58b566770c81a1a617f63e">psa_key_attributes_t</a> *attributes, uint8_t *pubkey, size_t pubkey_size, size_t *pubkey_length)</td></tr>
<tr class="memdesc:ga62df4bbc6b63ab5ef8183012b12a6cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that generates a symmetric or asymmetric key on a secure element.  <a href="group__se__key__management.html#ga62df4bbc6b63ab5ef8183012b12a6cf8">More...</a><br /></td></tr>
<tr class="separator:ga62df4bbc6b63ab5ef8183012b12a6cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga984d5535962320e0c4692bb4ede486ef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__se__key__management.html#ga984d5535962320e0c4692bb4ede486ef">psa_key_creation_method_t</a> { <br />
&#160;&#160;<a class="el" href="group__se__key__management.html#gga984d5535962320e0c4692bb4ede486efa9d61c409158f958b864b759662adbbed">PSA_KEY_CREATION_IMPORT</a>
, <a class="el" href="group__se__key__management.html#gga984d5535962320e0c4692bb4ede486efab197db75a74e331a570562ba3b3e04a9">PSA_KEY_CREATION_GENERATE</a>
, <a class="el" href="group__se__key__management.html#gga984d5535962320e0c4692bb4ede486efaae615ce8bde386039d1ee1b348f6552c">PSA_KEY_CREATION_DERIVE</a>
, <a class="el" href="group__se__key__management.html#gga984d5535962320e0c4692bb4ede486efa61d76b2af65ab3fb904b5eedd8f46363">PSA_KEY_CREATION_COPY</a>
, <br />
&#160;&#160;<a class="el" href="group__se__key__management.html#gga984d5535962320e0c4692bb4ede486efabcea58ac75861648df36ae58a8562257">PSA_KEY_CREATION_REGISTER</a>
<br />
 }</td></tr>
<tr class="separator:ga984d5535962320e0c4692bb4ede486ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Currently, key management is limited to importing keys in the clear, destroying keys, and exporting keys in the clear. Whether a key may be exported is determined by the key policies in place on the key slot. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaab9a5d39285c68ac29264017e0119d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab9a5d39285c68ac29264017e0119d98">&#9670;&nbsp;</a></span>psa_drv_se_allocate_key_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(* psa_drv_se_allocate_key_t) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, void *persistent_data, const <a class="el" href="group__attributes.html#ga8eedc0a49d58b566770c81a1a617f63e">psa_key_attributes_t</a> *attributes, <a class="el" href="group__se__key__management.html#ga984d5535962320e0c4692bb4ede486ef">psa_key_creation_method_t</a> method, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> *key_slot)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that allocates a slot for a key. </p>
<p>To create a key in a specific slot in a secure element, the core first calls this function to determine a valid slot number, then calls a function to create the key material in that slot. In nominal conditions (that is, if no error occurs), the effect of a call to a key creation function in the PSA Cryptography API with a lifetime that places the key in a secure element is the following:</p><ol type="1">
<li>The core calls <a class="el" href="structpsa__drv__se__key__management__t.html#ada92ba1ee99afb1e8ac719e2feeee4cc">psa_drv_se_key_management_t::p_allocate</a> (or in some implementations <a class="el" href="structpsa__drv__se__key__management__t.html#a45c3a420a662f4bf67b4eaed5038fb34">psa_drv_se_key_management_t::p_validate_slot_number</a>). The driver selects (or validates) a suitable slot number given the key attributes and the state of the secure element.</li>
<li>The core calls a key creation function in the driver.</li>
</ol>
<p>The key creation functions in the PSA Cryptography API are:</p><ul>
<li><a class="el" href="group__import__export.html#gad088d8ebc854d2f7a5b5c1769bc9ed40" title="Import a key in binary format.">psa_import_key()</a>, which causes a call to <code>p_allocate</code> with <code>method</code> = <a class="el" href="group__se__key__management.html#gga984d5535962320e0c4692bb4ede486efa9d61c409158f958b864b759662adbbed">PSA_KEY_CREATION_IMPORT</a> then a call to <a class="el" href="structpsa__drv__se__key__management__t.html#a6764bfd7ca6d9822b2a98c0830a722de">psa_drv_se_key_management_t::p_import</a>.</li>
<li><a class="el" href="group__random.html#ga950b4199ae7a0164006bd3d6927d1efe" title="Generate a key or key pair.">psa_generate_key()</a>, which causes a call to <code>p_allocate</code> with <code>method</code> = <a class="el" href="group__se__key__management.html#gga984d5535962320e0c4692bb4ede486efab197db75a74e331a570562ba3b3e04a9">PSA_KEY_CREATION_GENERATE</a> then a call to <a class="el" href="structpsa__drv__se__key__management__t.html#a6764bfd7ca6d9822b2a98c0830a722de">psa_drv_se_key_management_t::p_import</a>.</li>
<li><a class="el" href="group__key__derivation.html#gad286b675f3f8b46fa6cab620de6bead3">psa_key_derivation_output_key()</a>, which causes a call to <code>p_allocate</code> with <code>method</code> = <a class="el" href="group__se__key__management.html#gga984d5535962320e0c4692bb4ede486efaae615ce8bde386039d1ee1b348f6552c">PSA_KEY_CREATION_DERIVE</a> then a call to <a class="el" href="structpsa__drv__se__key__derivation__t.html#a81357f9add831e2866698c2c05deffef">psa_drv_se_key_derivation_t::p_derive</a>.</li>
<li><a class="el" href="group__key__management.html#ga78da90274bd8f8680017a4bb513803a1">psa_copy_key()</a>, which causes a call to <code>p_allocate</code> with <code>method</code> = <a class="el" href="group__se__key__management.html#gga984d5535962320e0c4692bb4ede486efa61d76b2af65ab3fb904b5eedd8f46363">PSA_KEY_CREATION_COPY</a> then a call to <a class="el" href="structpsa__drv__se__key__management__t.html#a28d37267c379b03e48fa4a3134d7c71b">psa_drv_se_key_management_t::p_export</a>.</li>
</ul>
<p>In case of errors, other behaviors are possible.</p><ul>
<li>If the PSA Cryptography subsystem dies after the first step, for example because the device has lost power abruptly, the second step may never happen, or may happen after a reset and re-initialization. Alternatively, after a reset and re-initialization, the core may call <a class="el" href="structpsa__drv__se__key__management__t.html#ab5bfb924e670c3aa65093a27ede91780">psa_drv_se_key_management_t::p_destroy</a> on the slot number that was allocated (or validated) instead of calling a key creation function.</li>
<li>If an error occurs, the core may call <a class="el" href="structpsa__drv__se__key__management__t.html#ab5bfb924e670c3aa65093a27ede91780">psa_drv_se_key_management_t::p_destroy</a> on the slot number that was allocated (or validated) instead of calling a key creation function.</li>
</ul>
<p>Errors and system resets also have an impact on the driver's persistent data. If a reset happens before the overall key creation process is completed (before or after the second step above), it is unspecified whether the persistent data after the reset is identical to what it was before or after the call to <code>p_allocate</code> (or <code>p_validate_slot_number</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">drv_context</td><td>The driver context structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">persistent_data</td><td>A pointer to the persistent data that allows writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributes</td><td>Attributes of the key. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">method</td><td>The way in which the key is being created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_slot</td><td>Slot where the key will be stored. This must be a valid slot for a key of the chosen type. It must be unoccupied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>Success. The core will record <code>*key_slot</code> as the key slot where the key is stored and will update the persistent data in storage. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga1dcc6d130633ed5db8942257581b55dd">PSA_ERROR_NOT_SUPPORTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga897a45eb206a6f6b7be7ffbe36f0d766">PSA_ERROR_INSUFFICIENT_STORAGE</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf8c22c4a5b87035fcb594858d68e1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf8c22c4a5b87035fcb594858d68e1ba">&#9670;&nbsp;</a></span>psa_drv_se_destroy_key_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(* psa_drv_se_destroy_key_t) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, void *persistent_data, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that destroys a secure element key and restore the slot to its default state. </p>
<p>This function destroys the content of the key from a secure element. Implementations shall make a best effort to ensure that any previous content of the slot is unrecoverable.</p>
<p>This function returns the specified slot to its default state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">drv_context</td><td>The driver context structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">persistent_data</td><td>A pointer to the persistent data that allows writing. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_slot</td><td>The key slot to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>The slot's content, if any, has been erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c51abdf1eb2165b800f1de017ed42fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c51abdf1eb2165b800f1de017ed42fb">&#9670;&nbsp;</a></span>psa_drv_se_export_key_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(* psa_drv_se_export_key_t) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key, uint8_t *p_data, size_t data_size, size_t *p_data_length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that exports a secure element key in binary format. </p>
<p>The output of this function can be passed to <a class="el" href="group__import__export.html#gad088d8ebc854d2f7a5b5c1769bc9ed40" title="Import a key in binary format.">psa_import_key()</a> to create an equivalent object.</p>
<p>If a key is created with <code><a class="el" href="group__import__export.html#gad088d8ebc854d2f7a5b5c1769bc9ed40" title="Import a key in binary format.">psa_import_key()</a></code> and then exported with this function, it is not guaranteed that the resulting data is identical: the implementation may choose a different representation of the same key if the format permits it.</p>
<p>This function should generate output in the same format that <code><a class="el" href="group__import__export.html#ga5f2f7c851186c5d1d928be0b6020225c" title="Export a key in binary format.">psa_export_key()</a></code> does. Refer to the documentation of <code><a class="el" href="group__import__export.html#ga5f2f7c851186c5d1d928be0b6020225c" title="Export a key in binary format.">psa_export_key()</a></code> for the format for each key type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">drv_context</td><td>The driver context structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Slot whose content is to be exported. This must be an occupied key slot. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_data</td><td>Buffer where the key data is to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of the <code>p_data</code> buffer in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_data_length</td><td>On success, the number of bytes that make up the key data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga18646babb2ae6cbde02ea3828bbd9141">PSA_ERROR_DOES_NOT_EXIST</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga1dcc6d130633ed5db8942257581b55dd">PSA_ERROR_NOT_SUPPORTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga08b10e70fa5ff0b05c631d9f8f6b2c6b">PSA_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga62df4bbc6b63ab5ef8183012b12a6cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62df4bbc6b63ab5ef8183012b12a6cf8">&#9670;&nbsp;</a></span>psa_drv_se_generate_key_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(* psa_drv_se_generate_key_t) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot, const <a class="el" href="group__attributes.html#ga8eedc0a49d58b566770c81a1a617f63e">psa_key_attributes_t</a> *attributes, uint8_t *pubkey, size_t pubkey_size, size_t *pubkey_length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that generates a symmetric or asymmetric key on a secure element. </p>
<p>If the key type <code>type</code> recorded in <code>attributes</code> is asymmetric (<a class="el" href="group__crypto__types.html#gab138ae2ebf2905dfbaf4154db2620939">PSA_KEY_TYPE_IS_ASYMMETRIC</a>(<code>type</code>) = 1), the driver may export the public key at the time of generation, in the format documented for <a class="el" href="group__import__export.html#ga76970efac4f9418a03bf59dc345eaf88" title="Export a public key or the public part of a key pair in binary format.">psa_export_public_key()</a> by writing it to the <code>pubkey</code> buffer. This is optional, intended for secure elements that output the public key at generation time and that cannot export the public key later. Drivers that do not need this feature should leave <code>*pubkey_length</code> set to 0 and should implement the psa_drv_key_management_t::p_export_public function. Some implementations do not support this feature, in which case <code>pubkey</code> is <code>NULL</code> and <code>pubkey_size</code> is 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">drv_context</td><td>The driver context structure. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_slot</td><td>Slot where the key will be stored. This must be a valid slot for a key of the chosen type. It must be unoccupied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributes</td><td>The key attributes, including the lifetime, the key type and size, and the usage policy. Drivers can call psa_get_key_lifetime(), psa_get_key_type(), psa_get_key_bits(), psa_get_key_usage_flags() and psa_get_key_algorithm() to access this information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pubkey</td><td>A buffer where the driver can write the public key, when generating an asymmetric key pair. This is <code>NULL</code> when generating a symmetric key or if the core does not support exporting the public key at generation time. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pubkey_size</td><td>The size of the <code>pubkey</code> buffer in bytes. This is 0 when generating a symmetric key or if the core does not support exporting the public key at generation time. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pubkey_length</td><td>On entry, this is always 0. On success, the number of bytes written to <code>pubkey</code>. If this is 0 or unchanged on return, the core will not read the <code>pubkey</code> buffer, and will instead call the driver's psa_drv_key_management_t::p_export_public function to export the public key when needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e04e71aff4837259e54598708edcf7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e04e71aff4837259e54598708edcf7d">&#9670;&nbsp;</a></span>psa_drv_se_import_key_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(* psa_drv_se_import_key_t) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot, const <a class="el" href="group__attributes.html#ga8eedc0a49d58b566770c81a1a617f63e">psa_key_attributes_t</a> *attributes, const uint8_t *data, size_t data_length, size_t *bits)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that imports a key into a secure element in binary format. </p>
<p>This function can support any output from <a class="el" href="group__import__export.html#ga5f2f7c851186c5d1d928be0b6020225c" title="Export a key in binary format.">psa_export_key()</a>. Refer to the documentation of <a class="el" href="group__import__export.html#ga5f2f7c851186c5d1d928be0b6020225c" title="Export a key in binary format.">psa_export_key()</a> for the format for each key type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">drv_context</td><td>The driver context structure. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_slot</td><td>Slot where the key will be stored. This must be a valid slot for a key of the chosen type. It must be unoccupied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributes</td><td>The key attributes, including the lifetime, the key type and the usage policy. Drivers should not access the key size stored in the attributes: it may not match the data passed in <code>data</code>. Drivers can call psa_get_key_lifetime(), psa_get_key_type(), psa_get_key_usage_flags() and psa_get_key_algorithm() to access this information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Buffer containing the key data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_length</td><td>Size of the <code>data</code> buffer in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bits</td><td>On success, the key size in bits. The driver must determine this value after parsing the key according to the key type. This value is not used if the function fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>Success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26c4b96c6d68dbd74b0512475d29f934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26c4b96c6d68dbd74b0512475d29f934">&#9670;&nbsp;</a></span>psa_drv_se_validate_slot_number_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(* psa_drv_se_validate_slot_number_t) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, void *persistent_data, const <a class="el" href="group__attributes.html#ga8eedc0a49d58b566770c81a1a617f63e">psa_key_attributes_t</a> *attributes, <a class="el" href="group__se__key__management.html#ga984d5535962320e0c4692bb4ede486ef">psa_key_creation_method_t</a> method, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that determines whether a slot number is valid for a key. </p>
<p>To create a key in a specific slot in a secure element, the core first calls this function to validate the choice of slot number, then calls a function to create the key material in that slot. See the documentation of <a class="el" href="group__se__key__management.html#gaab9a5d39285c68ac29264017e0119d98" title="A function that allocates a slot for a key.">psa_drv_se_allocate_key_t</a> for more details.</p>
<p>As of the PSA Cryptography API specification version 1.0, there is no way for applications to trigger a call to this function. However some implementations offer the capability to create or declare a key in a specific slot via implementation-specific means, generally for the sake of initial device provisioning or onboarding. Such a mechanism may be added to a future version of the PSA Cryptography API specification.</p>
<p>This function may update the driver's persistent data through <code>persistent_data</code>. The core will save the updated persistent data at the end of the key creation process. See the description of <a class="el" href="group__se__key__management.html#gaab9a5d39285c68ac29264017e0119d98" title="A function that allocates a slot for a key.">psa_drv_se_allocate_key_t</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">drv_context</td><td>The driver context structure. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">persistent_data</td><td>A pointer to the persistent data that allows writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributes</td><td>Attributes of the key. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">method</td><td>The way in which the key is being created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_slot</td><td>Slot where the key is to be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>The given slot number is valid for a key with the given attributes. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td>The given slot number is not valid for a key with the given attributes. This includes the case where the slot number is not valid at all. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gaf2b34cc87edc72f3ba90071a08210d20">PSA_ERROR_ALREADY_EXISTS</a></td><td>There is already a key with the specified slot number. Drivers may choose to return this error from the key creation function instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga984d5535962320e0c4692bb4ede486ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga984d5535962320e0c4692bb4ede486ef">&#9670;&nbsp;</a></span>psa_key_creation_method_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__se__key__management.html#ga984d5535962320e0c4692bb4ede486ef">psa_key_creation_method_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enumeration indicating how a key is created. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga984d5535962320e0c4692bb4ede486efa9d61c409158f958b864b759662adbbed"></a>PSA_KEY_CREATION_IMPORT&#160;</td><td class="fielddoc"><p>During <a class="el" href="group__import__export.html#gad088d8ebc854d2f7a5b5c1769bc9ed40" title="Import a key in binary format.">psa_import_key()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga984d5535962320e0c4692bb4ede486efab197db75a74e331a570562ba3b3e04a9"></a>PSA_KEY_CREATION_GENERATE&#160;</td><td class="fielddoc"><p>During <a class="el" href="group__random.html#ga950b4199ae7a0164006bd3d6927d1efe" title="Generate a key or key pair.">psa_generate_key()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga984d5535962320e0c4692bb4ede486efaae615ce8bde386039d1ee1b348f6552c"></a>PSA_KEY_CREATION_DERIVE&#160;</td><td class="fielddoc"><p>During <a class="el" href="group__key__derivation.html#gad286b675f3f8b46fa6cab620de6bead3">psa_key_derivation_output_key()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga984d5535962320e0c4692bb4ede486efa61d76b2af65ab3fb904b5eedd8f46363"></a>PSA_KEY_CREATION_COPY&#160;</td><td class="fielddoc"><p>During <a class="el" href="group__key__management.html#ga78da90274bd8f8680017a4bb513803a1">psa_copy_key()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga984d5535962320e0c4692bb4ede486efabcea58ac75861648df36ae58a8562257"></a>PSA_KEY_CREATION_REGISTER&#160;</td><td class="fielddoc"><p>A key is being registered with iotex_psa_register_se_key(). </p><pre class="fragment">   The core only passes this value to
   psa_drv_se_key_management_t::p_validate_slot_number, not to
   psa_drv_se_key_management_t::p_allocate. The call to
   `p_validate_slot_number` is not followed by any other call to the
   driver: the key is considered successfully registered if the call to
   `p_validate_slot_number` succeeds, or if `p_validate_slot_number` is
   null.

   With this creation method, the driver must return #PSA_SUCCESS if
   the given attributes are compatible with the existing key in the slot,
   and #PSA_ERROR_DOES_NOT_EXIST if the driver can determine that there
   is no key with the specified slot number.

   This is an Mbed Crypto extension.
</pre> </td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
